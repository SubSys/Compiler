module Complex.SystemOne exposing (..)


import Native.Core
import Native.Core.List


infixl 6 +
infixl 6 -
infixl 6 *
infixl 6 /

infix 4 ==
infix 4 /=
infix 4 <
infix 4 >
infix 4 <=
infix 4 >=

infixr 3 &&
infixr 2 ||


-- *
-- | Misc. Utils
-- *
infixr 0 <|
infixl 0 |>

(|>) : a -> (a -> b) -> b
(|>) x f =
  f x

(<|) : (a -> b) -> a -> b
(<|) f x =
  f x








-- *
-- | Arithmetic Operators
-- *
{-|-}
(+) : number -> number -> number
(+) =
  Native.Core.add

{-|-}
(-) : number -> number -> number
(-) =
  Native.Core.sub

{-|-}
(*) : number -> number -> number
(*) =
  Native.Core.mul


{-| Floating point division. -}
(/) : Float -> Float -> Float
(/) =
  Native.Core.floatDiv







-- *
-- | Logical Operators
-- *
(==) : a -> a -> Bool
(==) =
  Native.Core.equal

(/=) : a -> a -> Bool
(/=) =
  Native.Core.notEqual


{-|-}
(<) : comparable -> comparable -> Bool
(<) =
  Native.Core.lt


{-|-}
(>) : comparable -> comparable -> Bool
(>) =
  Native.Core.gt


{-|-}
(<=) : comparable -> comparable -> Bool
(<=) =
  Native.Core.le


{-|-}
(>=) : comparable -> comparable -> Bool
(>=) =
  Native.Core.ge


(&&) : Bool -> Bool -> Bool
(&&) =
  Native.Core.and

(||) : Bool -> Bool -> Bool
(||) =
  Native.Core.or





-- *
-- | Core.List 
-- *

infixr 5 ::
infixr 5 ++


(++) : appendable -> appendable -> appendable
(++) =
  Native.Core.append

(::) : a -> List a -> List a
(::) =
    Native.Core.List.cons


map : (a -> b) -> List a -> List b
map f xs =
  foldr (\x acc -> f x :: acc) [] xs



foldl : (a -> b -> b) -> b -> List a -> b
foldl func acc list =
  case list of
    [] ->
      acc

    x :: xs ->
      foldl func (func x acc) xs



foldr : (a -> b -> b) -> b -> List a -> b
foldr fn acc ls =
    foldrHelper fn acc 0 ls



foldrHelper : (a -> b -> b) -> b -> Int -> List a -> b
foldrHelper fn acc ctr ls =
    case ls of
        [] ->
            acc

        a :: r1 ->
            case r1 of
                [] ->
                    fn a acc

                b :: r2 ->
                    case r2 of
                        [] ->
                            fn a (fn b acc)

                        c :: r3 ->
                            case r3 of
                                [] ->
                                    fn a (fn b (fn c acc))

                                d :: r4 ->
                                    let
                                        res =
                                            if ctr > 500 then
                                                foldl fn acc <| reverse r4
                                            else
                                                foldrHelper fn acc (ctr + 1) r4
                                    in
                                        fn a (fn b (fn c (fn d res)))




reverse : List a -> List a
reverse list =
  foldl (::) [] list






-- *
-- | Basic Data Types
-- *

type Maybe a
    = Nothing
    | Just a

type Result error value
    = Err error
    | Ok value







-- *
-- | Application Code
-- *



type Lister a = Empty | Node a Lister



type Color = Red | Green | Blue


type ColorWrapper a = ColorPayload a




type Name = String





fibonacci : Int -> Int
fibonacci n =
    case n of
        1 -> 1
        2 -> 1
        _ -> fibonacci (n-1) + fibonacci (n-2)



repeat : Int -> a -> List a
repeat n x =
    if n <= 0 then
        []
    else 
        x :: repeat (n-1) x





alpha : Color -> ColorWrapper Color
alpha x =
    case x of
        Red -> ColorPayload Red
        Green -> ColorPayload Green
        Blue -> ColorPayload Blue


beta x y z =
    x + y + z

gamma z =
    beta 1 2 z


